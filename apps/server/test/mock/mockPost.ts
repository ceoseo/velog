export type MockPostsType = (typeof mockPosts)[0]
export const mockPosts = [
  {
    title: '리액트 프로젝트에서 타입스크립트 사용하기',
    body: '이번에 올리게 될 개발 튜토리얼 시리즈에서는 리액트 프로젝트에서 타입스크립트를 사용하는 방법에 대하여 알아보겠습니다.\n\nJavaScript 는 Weakly-typed 된 언어이기 때문에 특정 숫자 변수를 선언 한 다음에 그 안에 다른 타입의 값을 담을 수 있어요. 예를 들자면, 숫자로 선언한 변수에 문자열을 넣을 수도 있고, `null`을 넣을 수도 있고 배열을 넣을 수도 있고 객체를 넣을 수도 있죠.\n\n```javascript\nlet value = 5;\nvalue = \'안녕하세요\';\nvalue = [1, 2, 3, 4, 5];\nvalue = null;\n```\n\n이로 인하여 우리가 실수를 저지를 확률이 생기게 되버리죠. 예를 들어서 배열인줄 알고 특정 값의 배열 내장 함수를 사용하려고 했는데 알고보니 `null` 이여서 앱이 크래쉬가 뜬다던지.. 숫자인줄 알고 비교했는데 알고보니 문자열이였다던지..\n\n추가적으로, JavaScript를 사용 할 땐 IDE 지원이 좀 부족합니다. 작동하지 않습니다. 아마 C++, Java, C# 등의 언어를 사용하신 경험이 있으시다면 JavaScript IDE 에서 지원하는 자동완성 시스템이나 오류 확인 시스템에 은근히 불만이 있을거예요.\n\n## JavaScript 의 불편함\n\n### 자동완성이 구리다.\n\n예를 들자면, VS Code 를 사용 할 때 이 정도의 자동완성은 됩니다.\n\n![image.png](https://images.velog.io/post-images/velopert/1ead1cd0-df9a-11e9-a678-e775d1643dee/image.png)\n\n그런데 배열을 파라미터로 값으로 받아오는 함수를 만들게 될 때 해당 함수 내부에서는 자동완성이 안됩니다.\n\n![image.png](https://images.velog.io/post-images/velopert/37020e30-df9a-11e9-a678-e775d1643dee/image.png)\n\n### 함수 파라미터 타입 체킹 안해준다.\n아니면.. 문자열을 가지고 어떤 처리를 하는 함수를 만들었다고 가정해봅시다.\n\n```javascript\nfunction getLength(str) {\n  return str.length;\n}\n```\n\n그런데 해당 함수를 다음과 같이 숫자를 넣어서 호출해도 전혀 문제가 안됩니다.\n\n```javascript\ngetLength(3);\n```\n\n다른 언어였으면 파라미터 타입이 이상하다면서 오류를 냈을텐데 말이죠, 자바스크립트 환경에서는 실행해볼때까지 해당 코드에 오류가 있는지 없는지 알 방법이 없습니다.\n\n### 리덕스 쓸 때 불편하다.\n\n리액트를 사용하는 경우 실무에서 실제로 겪을 수 있는 불편함 중에서는 다음과 같은 상황이 있습니다. 예를 들어서 여러분들이 리덕스를 사용해서, `useSelector` 를 통해 리덕스 스토어 안에 들어있는 상태를 조회한다고 가정을 해봅시다.\n\n![image.png](https://images.velog.io/post-images/velopert/c822c3f0-df9a-11e9-b1fa-2523c5d94a4f/image.png)\n\n그럼 상태 안에 어떤 값이 들어있는지 에디터 단에서 모르기 때문에, Redux DevTools 를 한번 확인해보거나, 리듀서 관련 코드가 들어있는 파일을 열어서 그 안에 어떤 상태가 들어있더라..! 하고 열어보아야 한다는 귀찮음이 있습니다.\n\n### 리액트 컴포넌트 쓸 때 어떤 props 를 넣어야하는지 에디터에서 알 방법이 없다.\n리액트 컴포넌트에서는 `propTypes` 라는 것을 사용하면 특정 컴포넌트에서 필요한 `props` 를 지정해서 컴포넌트에서 필요한 `props` 가 없다면 콘솔에 경고를 출력하도록 할 수 있습니다.\n\n그런데요, `propTypes` 쓰는거 솔직히 너무 귀찮습니다. 특히 `props` 로 배열이나 객체 가져와야 하는경우엔 무슨 `arrayOf`, `shape` 이런거 써야 되고 여러 타입인 경우엔 `oneOfType` 란걸 써야 하는데 솔직히 너무 안외워지고 불편합니다. \n\n그리고, `propTypes` 를 설정해도 `props` 빠뜨리면 브라우저 단에서만 경고를 보여줄 뿐 에디터에서는 아무 경고도 보여주지 않기 때문에 실제로 코드를 실행해봐야만 우리가 실수를 했는지 안했는지 알 수가 있다는게 참 불편합니다.\n\n## 처음엔 불편한지 모른다\n\n이렇게 끝도 없이 JavaScript 의 불편함에 대해서 계속해서 나열 할 수 있습니다. 하지만 아마 대부분 처음엔 불편한지 모릅니다. 저도 마찬가지예요. 처음엔 불편한지 몰랐어요. TypeScript 를 사용해본 분이라면 불편함을 심하게 느낄 겁니다. TypeScript를 경험해본 정말 많은 개발자분들은 다들 "TypeScript 없이 어떻게 개발을 하지?" 라는 생각을 하게 됩니다. \n\n한번 써보면, 얼마나 불편한지 깨달을 수 있습니다. 그리고 정말, 여러분의 개발 생산성을 매우 향상시켜줄거예요. 특히 리액트 프로젝트에서 타입스크립트 쓰면 진짜 개발 편해집니다. \n\n## 써야 하는 이유\n\n써야 하는 이유: _**"정말 좋다."**_ 이 한마디로 다 설명 되지만 제가 생각하기에 3가지 가장 큰 강점들을 나열해보자면 다음과 같은 큰 장점이 있습니다.\n\n1.  **IDE 를 더욱 적극적으로 활용 할 수 있습니다.**\n\t자동완성 및 타입 체킹이 되기 떄문에 개발 생산성이 정말 높아집니다. 어떤 컴포넌트를 사용하거나, 함수를 사용 할 때 해당 파일을 직접 얼여보지 않고도 어떤 props 또는 파라미터를 넣어줘야 하는지 알 수 있습니다. 리덕스를 사용하게 될 때에도, 리듀서 관련 코드를 열지 않고도 상태 객체가 어떤 구조로 이루어졌는지 확인 할 수 있죠\n\n2. **바보같은 실수, 줄일 수 있다.**\n\t때로는, 우리는 바보같은 실수를 합니다. 아 왜 내가 이런 실수를 했지! 하며.. 에를 들어서 함수에 타입을 잘못 설정했다던지, 이상한 오타를 냈다던지, 다른 타입끼리 비교를 했다던지.. `null` 체킹을 빠뜨렸다던지..  TypeScript 를 사용하면 이런 실수들을 코드를 실행해보기 전에도 에디터 단에서 바로 알 수 있기 때문에 실수를 많이 줄일 수 있답니다.\n    \n3. **협업 할 때 유용하다**\n\t결국 위에 언급했던 1번의 연장선입니다. IDE에서 컴포넌트, 함수 등을 사용 할 때 어떤 값을 어떤 타입으로 넣어야 하는지 바로 IDE상에서 확인 할 수 있기 때문에 굳이 주석으로 작성하거나, 코드를 읽어보거나, 협업하는 사람에게 물어보지 않아도 쉽게 사용 할 수 있습니다.\t\n    \n    \n## 앞으로 이 시리즈에서 다룰 내용\n이 시리즈를 진행하기 전에, TypeScript를 이미 잘 알고있다면 참 좋겠지만, 그렇지 않은 독자분들께서도 쉽게 타입스크립트에 입문하고 리액트 프로젝트에 적용 할 수 있도록 리액트에서 TypeScript를 활용하기 위해 핊요한 기본기를 가볍게 다룹니다. 이 튜토리얼에서는 모든 기능을 세세하게 다루진 않기 때문에 TypeScript를 꼼꼼하게 배워보고 싶다면 다음 링크를 참고해보세요.\n\n- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/basic-types.html)\n- [TypeScript Handbook 한글 문서](https://typescript-kr.github.io/)\n\n먼저 타입스크립트의 기본기를 배우고 난 다음에는 타입스크립트가 적용된 리액트 프로젝트를 만들고, 컴포넌트를 작성 할 때 타입스크립트로 작성하는 방법에 대해서 다뤄보게 됩니다.\n\n이 튜토리얼에서는 클래스형 컴포넌트를 타입스크립트를 작성하는 것에 대해서 다루지 않습니다. 따라서, 나중에 클래스 컴포넌트를 작성하는 방법을 알아보시려면 이 [링크](https://github.com/typescript-cheatsheets/react-typescript-cheatsheet#class-components)를 참고하세요. 클래스 컴포넌트를 다루지 않는 이유는 앞으로 여러분도, 저도 클래스 컴포넌트를 사용 할 일이 별로 없을거라고 생각하기 때문이고 글을 쓰는 것 또한 불필요한 리소스라고 생각하기 때문입니다.\n\n이 튜토리얼에서는 함수형 컴포넌트와, Hooks 를 사용하는 것에 집중합니다. 따라서, 우리는 TypeScript 환경에서 `useState` 또는 `useReducer` 를 사용하여 상태관리를 하는 방법을 배우겠습니다.\n\n추가적으로, 글로벌 상태관리를 할 때를 대비하여 Context API를 활용하는 방법도 빠질 수 없죠. 효율적으로 TypeScript와 Context API 를 사용하는 방법 또한 다뤄보게 됩니다.\n\n그리고 리덕스를 다루는 방법도 배워 볼 것이구요, `typesafe-actions` 라는 라이브러리를 사용하여 정말 깔끔하게 액션 생성함수와 리듀서를 작성하는 방법도 배워볼겁니다. 그리고, 제가 요즘 좋아하는 리덕스 모듈의 디렉터리 구조도 소개시켜드릴게요.\n\n마지막으로, 리덕스 미들웨어를 사용하는 방법도 다뤄볼것입니다. 이 때 우리는 redux-thunk 와 redux-saga 를 사용해보게 됩니다.\n\n\n\n',
    short_description: null,
    thumbnail:
      'https://images.velog.io/post-images/velopert/fb967da0-dfb1-11e9-b08c-3566efc94aa4/ts-and-react.png',
    is_markdown: true,
    is_temp: false,
    original_post_id: null,
    url_slug: 'using-react-with-typescript',
    likes: 129,
    meta: {
      code_theme: '',
      short_description:
        '이번에 올리게 될 개발 튜토리얼 시리즈에서는 리액트 프로젝트에서 타입스크립트를 사용하는 방법에 대하여 알아보겠습니다.  JavaScript 는 Weakly-typed 된 언어이기 때문에 특정 숫자 변수를 선언 한 다음에 그 안에 다른 타입의 값을 담을 수 있어요. 예를 들자면, 숫자로 선언한 변수에 문자열을 넣을 수도 있고, null을 넣을 수도 있고 배열...',
    },
    is_private: false,
    released_at: '2019-09-27T05:04:47.242Z',
  },
  {
    title: 'Redux (3) 리덕스를 리액트와 함께 사용하기',
    body: "## 3-1. 리덕스의 3가지 규칙\n\n리덕스를 프로젝트에서 사용하게 될 때 알아둬야 할 3가지 규칙이 있습니다.\n\n### 1. 하나의 애플리케이션 안에는 하나의 스토어가 있습니다.\n\n하나의 애플리케이션에선 단 한개의 스토어를 만들어서 사용합니다. 여러개의 스토어를 사용하는것은 사실 가능하기는 하나, 권장되지는 않습니다.  특정 업데이트가 너무 빈번하게 일어나거나, 애플리케이션의 특정 부분을 완전히 분리시키게 될 때 여러개의 스토어를 만들 수도 있습니다. 하지만 그렇게 하면, 개발 도구를 활용하지 못하게 됩니다. \n\n### 2. 상태는 읽기전용 입니다.\n\n리액트에서 state 를 업데이트 해야 할 때, setState 를 사용하고, 배열을 업데이트 해야 할 때는 배열 자체에 push 를 직접 하지 않고, concat 같은 함수를 사용하여 기존의 배열은 수정하지 않고 새로운 배열을 만들어서 교체하는 방식으로 업데이트를 합니다. 엄청 깊은 구조로 되어있는 객체를 업데이트를 할 때도 마찬가지로, 기존의 객체는 건들이지 않고 `Object.assign` 을 사용하거나 spread 연산자 (`...`) 를 사용하여 업데이트 하곤 하죠.\n\n리덕스에서도 마찬가지입니다. 기존의 상태는 건들이지 않고 새로운 상태를 생성하여 업데이트 해주는 방식으로 해주면, 나중에 개발자 도구를 통해서 뒤로 돌릴 수도 있고 다시 앞으로 돌릴 수도 있습니다. \n\n리덕스에서 불변성을 유지해야 하는 이유는 내부적으로 데이터가 변경 되는 것을 감지하기 위하여 [shallow equality](https://redux.js.org/docs/faq/ImmutableData.html#how-redux-uses-shallow-checking) 검사를 하기 때문입니다. 이를 통하여 객체의 변화를 감지 할 때 객체의 깊숙한 안쪽까지 비교를 하는 것이 아니라 겉핥기 식으로 비교를 하여 좋은 성능을 유지할 수 있는 것이죠.\n\n우리는 이 튜토리얼에서는  Immutable.js 혹은 Immer.js 를 사용하여 불변성을 유지하며 상태를 관리하는 방법에 대해서 다뤄보게 됩니다. 불변성과 Immutable.js 가 익숙하지 않다면 [리액트의 불변함, 그리고 컴포넌트에서 Immutable.js 사용하기](https://velopert.com/3486) 포스트를 읽으시면 도움이 될거에요.\n\n\n### 3. 변화를 일으키는 함수, 리듀서는 순수한 함수여야 합니다.\n\n순수한 함수, 라는 개념이 익숙하지 않으시죠. 다음 사항을 기억해주세요.\n\n- 리듀서 함수는 이전 상태와, 액션 객체를 파라미터로 받습니다.\n- 이전의 상태는 절대로 건들이지 않고, 변화를 일으킨 새로운 상태 객체를 만들어서 반환합니다.\n- 똑같은 파라미터로 호출된 리듀서 함수는 **언제나** 똑같은 결과값을 반환해야만 합니다.\n\n3가지 사항을 주의해주세요. 동일한 인풋이라면 언제나 동일한 아웃풋이 있어야 합니다. 그런데 일부 로직들 중에서는 실행 할 때마다 다른 결과값이 나타날 수도 있죠. new Date() 를 사용한다던지.. 랜덤 숫자를 생성한다던지.. 혹은, 네트워크에 요청을 한다던지! 그러한 작업은 결코 순수하지 않은 작업이므로, 리듀서 함수의 바깥에서 처리해줘야 합니다. 그런것을 하기 위해서, [리덕스 미들웨어](https://velopert.com/3401) 를 사용하곤 하죠.\n\n## 3-2. 리액트와 함께 사용하기\n\n리덕스를 리액트와 함께 사용하는 방법을 알아봅시다. 우리는, 이러한 프로젝트를 만들어볼겁니다.\n\n![](https://i.imgur.com/Y7c667B.png)\n\n상단에는 알록달록한 카운터가 있습니다. 이 카운터에서는 팔레트에서 색상을 고를 수 있고, 여기서 고른 색상이 숫자의 색상으로 지정됩니다. 그리고 버튼을 누르면 값이 바뀌죠.\n\n하단에는 대기자 명단이 있습니다. 폼에서 이름을 등록을 추가하면 하단에 추가되고, 리스트에서 입장을 누르면 줄이 그어지고, 나감을 누르면 제거됩니다.\n\n시간을 효율적으로 활용하기 위하여, 컴포넌트 구성 및 스타일링은 생략하고, 껍데기만 이미 만들어진 프로젝트에서 진행하겠습니다.\n\n다음 명령어를 입력하시거나,\n\n```bash\n$ git clone https://github.com/vlpt-playground/learn-redux.git\n```\n\n이미 만들어둔 코드샌드박스 템플릿에서 진행하세요.\n\n[![Edit colorful-counter](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/nr66kv15xm)\n\n프로젝트를 열어서 내부에 어떤 컴포넌트들이 있는지 하나하나 살펴보세요. 상태관리는 아직 구현이 되어있지 않기 떄문에 버튼들을 클릭해도 작동하지는 않을겁니다.\n\n### 리액트에서 리덕스를 사용하기위해 필요한 라이브러리\n\n리액트 프로젝트에서 리덕스를 사용하려면 다음 라이브러리들이 설치되어야 합니다. (위 템플릿 프로젝트에는 이미 설치가 된 상태입니다.)\n\n- **redux**: 리덕스 모듈\n- **react-redux**: 리액트 컴포넌트에서 리덕스를 사용하기위한 유용한 도구들이 들어가있습니다.\n- **redux-actions**: 이 라이브러리를 꼭 설치 할 필요는 없습니다. 단, 알아두면 굉장히 유용합니다.\n\n준비가 다 되셨으면 하나하나 차근차근히 구현해봅시다!\n\n## 3-3. 알록달록 카운터 만들기\n\n알록달록 카운터를 만들어봅시다! [리덕스 공식 매뉴얼](https://redux.js.org/basics/example-todo-list) 을 보면 액션을 위한 파일과 리듀서를 위한 파일을 따로 작성합니다. 그렇게 하셔도 상관은 없는데 저는 개인적으로 불편하다고 생각합니다. 하나의 파일로 작성하는 방법도 있는데, 이를 [Ducks 패턴](https://github.com/erikras/ducks-modular-redux)이라고 합니다.\n\n우리는, 처음 배울떄부터 이 Ducks 패턴으로 개발을 하겠습니다.\n\n### counter 모듈 만들기\n\n특정 기능을 구현하기위하여 필요한 액션과, 액션생성함수와, 초깃값과, 리듀서함수가 들어있는 파일을 우리는 모듈 이라고 부릅니다. 그리고 이 파일은 src/store/modules 경로에 저장합니다.\n\nsrc/store/modules/counter.js 라는 새 파일을 만들어주세요.\n\n### 액션 타입 정의하기\n\n그 파일에, 우리가 카운터 쪽에서 사용할 액션들을 작성해주세요.\n\n#### src/store/modules/counter.js\n\n```javascript\n// 액션 타입 정의\nconst CHANGE_COLOR = 'counter/CHANGE_COLOR';\nconst INCREMENT = 'counter/INCREMENT';\nconst DECREMENT = 'counter/DECREMENT';\n```\n\nDucks 패턴을 사용 할 땐 위와 같이 액션 이름을 지을 때 문자열의 앞부분에 모듈 이름을 넣습니다. 이는, 다른 모듈에서 작성하게 될 수도 있는 액션들과 충돌되지 않게 하기 위함입니다.\n\n### 액션 생성함수 정의하기\n\n위에서 정의했던 액션 타입에 따라 액션 생성함수를 만들어주겠습니다.\n\n#### src/store/modules/counter.js\n\n```javascript\n// 액션 타입 정의\nconst CHANGE_COLOR = 'counter/CHANGE_COLOR';\nconst INCREMENT = 'counter/INCREMENT';\nconst DECREMENT = 'counter/DECREMENT';\n\n// **** 액션 생섬함수 정의\nexport const changeColor = color => ({ type: CHANGE_COLOR, color });\nexport const increment = () => ({ type: INCREMENT });\nexport const decrement = () => ({ type: DECREMENT });\n```\n\n액션 생성함수를 정의할땐 위와 같이 꼭 앞에 export 를 붙여주세요. 여기서 만든 함수들은 나중에 우리가 컴포넌트에 리덕스를 연동하고 불러와서 사용하게 됩니다.\n\n### 초기상태와 리듀서 정의\n\n이제 초기상태와 리듀서를 정의해주겠습니다.\n\n#### src/store/modules/counter.js\n\n```javascript\n// 액션 타입 정의\nconst CHANGE_COLOR = 'counter/CHANGE_COLOR';\nconst INCREMENT = 'counter/INCREMENT';\nconst DECREMENT = 'counter/DECREMENT';\n\n// 액션 생섬함수 정의\nexport const changeColor = color => ({ type: CHANGE_COLOR, color });\nexport const increment = () => ({ type: INCREMENT });\nexport const decrement = () => ({ type: DECREMENT });\n\n// **** 초기상태 정의\nconst initialState = {\n  color: 'red',\n  number: 0,\n};\n\n// **** 리듀서 작성\nexport default function counter(state = initialState, action) {\n  switch (action.type) {\n    case CHANGE_COLOR:\n      return {\n        ...state,\n        color: action.color,\n      };\n    case INCREMENT:\n      return {\n        ...state,\n        number: state.number + 1,\n      };\n    case DECREMENT:\n      return {\n        ...state,\n        number: state.number - 1,\n      };\n    default:\n      return state;\n  }\n}\n```\n\n리듀서 함수의 경우엔, 꼭 export default 를 해주어야합니다. 나중에 스토어를 만들 때, 이 함수를 필요로 합니다.\n\n이제 알록 달록 카윤터에서 필요로하는 리덕스 모듈을 다 만들었습니다.\n이제, 스토어를 만들어줄 차례인데요, 이번 프로젝트 같은 경우는, 앞으로 우리가 두개의 리듀서를 만들거여서 (아직은 만들지 않았지만) 여러개의 리듀서들을 합치는 작업을 해주어야 합니다.\n\n### combineReducers 로 리듀서 합치기\n\n리듀서가 여러개일대는 redux 의 내장함수인 combineReducers 를 사용하여 리듀서를 하나로 합치는 작업을 합니다. 여러개로 나뉘어진 리듀서들을 **서브리듀서** 라고 부르고, 하나로 합쳐진 리듀서를 **루트리듀서** 라고 부릅니다.\n\nmodules 디렉토리에 index.js 파일을 다음과 같이 만들어주세요\n\n#### src/store/modules/index.js\n\n```javascript\nimport { combineReducers } from 'redux';\nimport counter from './counter';\n\nexport default combineReducers({\n  counter,\n  // 다른 리듀서를 만들게되면 여기에 넣어줌..\n});\n```\n\n이렇게 리듀서를 합치게 되면, 루트 리듀서의 초깃값은 다음과 같은 구조로 됩니다.\n\n```javascript\n{\n  counter: {\n    color: 'red',\n    number: 0,\n  },\n  // ... 다른 리듀서에서 사용하는 초깃값들\n}\n```\n\n### 스토어 만들기\n\n이제 스토어를 만들어주겠습니다! 우리가 이전에 스토어를 만들때는 createStore 라는 함수를 사용하여 파라미터로는 리듀서를 넣어준다고 했었지요? 그리고, 리덕스의 3 가지 규칙을 배울떄 우리는 \"하나의 애플리케이션 안에는 하나의 스토어가 있습니다.\" 라고 배웠습니다.\n\n스토어는 여러분의 앱이 시작되는 src/index.js 쪽에서 딱 한번, 만드시면 됩니다.\n\n다음과 같이 코드를 작성해보세요.\n\n#### src/index.js\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n// **** (1) createStore 와 루트 리듀서 불러오기\nimport { createStore } from 'redux';\nimport rootReducer from './store/modules';\n\nimport './index.css';\nimport App from './App';\nimport registerServiceWorker from './registerServiceWorker';\n\n// **** (2) 스토어를 만들고 현재 값 확인해보기\nconst store = createStore(rootReducer);\nconsole.log(store.getState());\n\nReactDOM.render(<App />, document.getElementById('root'));\nregisterServiceWorker();\n```\n\n`store.getState()` 를 호출하셔서 현재 스토어의 값을 확인해보면 다음과 같이 나타날 것입니다.\n\n![](https://i.imgur.com/6zYcA03.png)\n\n[![Edit colorful-counter](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/z3v6j0v704)\n\n그럼 스토어를 성공적으로, 잘 만드신겁니다!\n\n### 리덕스 개발자 도구 적용하기\n\n리덕스 개발을 더욱 편하게 하기 위해서 Redux Devtools 라는 크롬 확장프로그램을 활용하시면 정말 편합니다. [크롬 웹스토어](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd) 에서 설치를 하시고, 스토어를 만들 때 다음과 같이 코드를 수정해주면 적용됩니다.\n\n#### src/index.js\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n// createStore 와 루트 리듀서 불러오기\nimport { createStore } from 'redux';\nimport rootReducer from './store/modules';\n\nimport './index.css';\nimport App from './App';\nimport registerServiceWorker from './registerServiceWorker';\n\n// **** 리덕스 개발자도구 적용\nconst devTools =\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__();\nconst store = createStore(rootReducer, devTools);\n\nReactDOM.render(<App />, document.getElementById('root'));\nregisterServiceWorker();\n```\n\n![](https://i.imgur.com/SRNrMha.png)\n\n### Provider 를 사용하여 리액트 프로젝트에 스토어 연동\n\n리액트 프로젝트에 스토어를 연동 할 때에는 react-redux 라이브러리 안에 들어있는 **Provider** 라는 컴포넌트를 사용합니다. 기존의 JSX 를 Provider 로 감싸고, store 는 props 로 Provider 한테 넣어주면 됩니다.\n\n#### src/index.js\n\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n// createStore 와 루트 리듀서 불러오기\nimport { createStore } from 'redux';\nimport rootReducer from './store/modules';\n// **** (1) Provider 불러오기\nimport { Provider } from 'react-redux';\n\nimport './index.css';\nimport App from './App';\nimport registerServiceWorker from './registerServiceWorker';\n\n// 리덕스 개발자도구 적용\nconst devTools =\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__();\nconst store = createStore(rootReducer, devTools);\n\n// **** (2) Provider 렌더링해서 기존의 App 감싸주기\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\nregisterServiceWorker();\n```\n\n### connect 함수를 사용하여 컴포넌트에 스토어 연동하기\n\n이제 우리는 컴포넌트에 리덕스 스토어 안에 있는 값이나 액션 함수들을 연동해줄건데요, 이렇게 리덕스와 연동된 컴포넌트를 우리는 컨테이너 컴포넌트라고 부릅니다. 그리고, 그냥 단순히 props 를 전달해주면 그대로 보여주는 컴포넌트들은 프리젠테이셔널 컴포넌트라고 부릅니다.\n\n컨테이너 컴포넌트는 똑똑한 (Smart) 컴포넌트, 프리젠테이셔널 컴포넌트는 멍청한 (Dumb) 컴포넌트라고 부르기도 합니다.\n\n[프리젠테이셔널 컴포넌트와 컨테이너 컴포넌트](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0), 이렇게 컴포넌트를 분류하는 방식은 리덕스의 창시자인 Dan Abramov 가 제시한 방법이고, 리덕스를 사용 할 때 이렇게 하면 좋다고 권장하긴 하지만, 무조건 따를 필요까지는 없습니다. (우리는 이 방식대로 개발하긴 할겁니다. 충분히 유용한 흐름입니다.)\n\n이러한 개발 방식에 있어서 최대 장점은 프리젠테이셔널 컴포넌트에선 UI 의 모양새에만 집중 할 수 있고, 컨테이너 컴포넌트쪽에서는 유저 인터랙션쪽에 집중 할 수 있다는 점이 있습니다.\n\nsrc 디렉토리에 containers 라는 디렉토리를 만들고, PaletteContainer 라는 컴포넌트를 만드세요.\n\n#### src/containers/PaletteContainer.js\n\n```javascript\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport Palette from '../components/Palette';\nimport { changeColor } from '../store/modules/counter';\n\nclass PaletteContainer extends Component {\n  handleSelect = color => {\n    const { changeColor } = this.props;\n    console.log('what');\n    changeColor(color);\n  };\n\n  render() {\n    const { color } = this.props;\n    return <Palette onSelect={this.handleSelect} selected={color} />;\n  }\n}\n\n// props 로 넣어줄 스토어 상태값\nconst mapStateToProps = state => ({\n  color: state.counter.color,\n});\n\n// props 로 넣어줄 액션 생성함수\nconst mapDispatchToProps = dispatch => ({\n  changeColor: color => dispatch(changeColor(color)),\n});\n\n// 컴포넌트에 리덕스 스토어를 연동해줄 때에는 connect 함수 사용\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(PaletteContainer);\n```\n\n컨테이너 컴포넌트를 만들땐, react-redux 안에 들어있는 `connect` 라는 함수를 사용합니다. 이 함수의 파라미터에 전달해주는 `mapStateToProps` 는 스토어 안에 들어있는 값을 props 로 전달해주고,\n`mapDispatchToProps` 는 액션 생성함수들을 props 로 전달해줍니다.\n\n여기서 mapDispatchToProps 가 조금 헷갈리실 수 도 있는데, 액션생성함수는, 호출한다고 해서 상태에 변화가 일어나는것이 아닙니다. 그 대신에, 액션 객체를 생성해내죠. 그 액션 객체를 스토어한테 전달해주어야 상태에 변화가 발생합니다.\n\n여기 있는 mapDispatchToProps 에서는, color 를 파라미터로 받아와서, 그 값을 가지고 CHANGE_COLOR 액션 객체를 생성한다음에 스토어한테 디스패치 하는 함수를, 컴포넌트의 props 로 전달해주는 것 이랍니다.\n\nconnect 함수가 호출되면, 반환되는 값은 특정 컴포넌트에 설정된 props 를 전달해주는 함수입니다. 지금 보시면 `connect(...)(PaletteContainer)` 이런식으로 호출되었는데, connect() 를 호출해서 반환받은 함수에, PaletteContainer 를 파라미터로 넣어서 호출한것이다 라고 이해하시면 됩니다.\n\n컨테이너 컴포넌트를 다 만드셨다면, App 에서 보여지는 Palette 를 PaletteContainer 로 대체하시구요,\n\n#### src/App.js\n\n```javascript\nimport React, { Component } from 'react';\n\nimport './App.css';\nimport Counter from './components/Counter';\nimport WaitingList from './components/WaitingList';\nimport PaletteContainer from './containers/PaletteContainer'; // **** (1) 불러오기\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <PaletteContainer /> {/* **** (2) 대체하기 */}\n        <Counter value={0} color=\"red\" />\n        <WaitingList />\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\nPalette 컴포넌트에서 PaletteItem 에 onClick 함수를 제대로 구현해주면, 팔레트에서 다른 색상을 클릭하시면 제대로 선택이 될 것입니다.\n\n#### src/components/Palette.js\n\n```javascript\nimport React from 'react';\nimport './Palette.css';\n\nconst colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\nconst PaletteItem = ({ color, active, onClick }) => {\n  return (\n    <div\n      className={`PaletteItem ${active ? 'active' : ''}`}\n      style={{ backgroundColor: color }}\n      onClick={onClick}\n    />\n  );\n};\n\nconst Palette = ({ selected, onSelect }) => {\n  return (\n    <div className=\"Palette\">\n      <h2>색깔을 골라골라</h2>\n      <div className=\"colors\">\n        {colors.map(color => (\n          <PaletteItem\n            color={color}\n            key={color}\n            active={selected === color}\n            onClick={() => onSelect(color)} // **** onClick 구현\n          />\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default Palette;\n```\n\n![](https://i.imgur.com/RYTDbI4.png)\n\n[![Edit colorful-counter](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/2133v9zvmn)\n\n이번엔, 비슷한 원리대로, CounterContainer 도 만들어보겠습니다.\n\n#### src/containers/CounterContainer.js\n\n```javascript\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport Counter from '../components/Counter';\nimport { increment, decrement } from '../store/modules/counter';\n\nclass CounterContainer extends Component {\n  handleIncrement = () => {\n    this.props.increment();\n  };\n  handleDecrement = () => {\n    this.props.decrement();\n  };\n  render() {\n    const { color, number } = this.props;\n    return (\n      <Counter\n        color={color}\n        value={number}\n        onIncrement={this.handleIncrement}\n        onDecrement={this.handleDecrement}\n      />\n    );\n  }\n}\n\nconst mapStateToProps = ({ counter }) => ({\n  color: counter.color,\n  number: counter.number,\n});\n\nconst mapDispatchToProps = dispatch => ({\n  increment: () => dispatch(increment()),\n  decrement: () => dispatch(decrement()),\n});\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(CounterContainer);\n``;\n```\n\nmapStateToProps 부분에서는, state 에 해당하는 부분을 비구조화 할당을 해주었습니다. 그러면, 각 값을 조회 할 떄마다 `state.` 를 생략해도 되겠죠?\n\n추가적으로 mapDispatchToProps 부분에선, 이번엔 액션이 두개가 있습니다. 계속 dispatch 해주기가 조금 귀찮죠? 그러한 경우엔 [bindActionCreators](https://redux.js.org/api-reference/bindactioncreators) 라는 함수를 사용하면 조금 더 쉽게 할 수 있습니다.\n\n#### src/containers/CounterContainer.js\n\n```javascript\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux'; // **** (1) 불러오기\nimport Counter from '../components/Counter';\nimport { increment, decrement } from '../store/modules/counter';\n\nclass CounterContainer extends Component {\n  handleIncrement = () => {\n    this.props.increment();\n  };\n  handleDecrement = () => {\n    this.props.decrement();\n  };\n  render() {\n    const { color, number } = this.props;\n    return (\n      <Counter\n        color={color}\n        value={number}\n        onIncrement={this.handleIncrement}\n        onDecrement={this.handleDecrement}\n      />\n    );\n  }\n}\n\nconst mapStateToProps = ({ counter }) => ({\n  color: counter.color,\n  number: counter.number,\n});\n\nconst mapDispatchToProps = dispatch =>\n  bindActionCreators({ increment, decrement }, dispatch); // **** (2) bindActionCreators 사용.\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(CounterContainer);\n```\n\n이렇게하면, 기존에 했던\n`actionCreator: (...params) => dispatch(actionCreator(...params)` 에 해당하는 작업을 자동으로 해줍니다. 만약에 액션 생성함수가 파라미터를 필요로 하는것이더라도, 정상적으로 작동합니다.\n\n또 다른 방식으로는 mapDispatchToProps 를 함수형태가 아닌 아예 액션생성함수로 이뤄진 객체를 전달해주면, connect 가 발생하게 될 때 bindActionCreators 를 자동으로 해줍니다.\n\n#### src/containers/CounterContainer.js\n\n```javascript\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport Counter from '../components/Counter';\nimport { increment, decrement } from '../store/modules/counter';\n\nclass CounterContainer extends Component {\n  handleIncrement = () => {\n    this.props.increment();\n  };\n  handleDecrement = () => {\n    this.props.decrement();\n  };\n  render() {\n    const { color, number } = this.props;\n    return (\n      <Counter\n        color={color}\n        value={number}\n        onIncrement={this.handleIncrement}\n        onDecrement={this.handleDecrement}\n      />\n    );\n  }\n}\n\nconst mapStateToProps = ({ counter }) => ({\n  color: counter.color,\n  number: counter.number,\n});\n\n// **** 함수가 아닌 객체 설정시 자동 bindActionCreators 됨\nconst mapDispatchToProps = { increment, decrement };\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(CounterContainer);\n```\n\n다 작성하셨으면, App 에서 Counter 대신 CounterContainer 를 보여주겠습니다.\n\n#### src/App.js\n\n```javascript\nimport React, { Component } from 'react';\n\nimport './App.css';\nimport WaitingList from './components/WaitingList';\nimport PaletteContainer from './containers/PaletteContainer';\nimport CounterContainer from './containers/CounterContainer'; // **** (1) 불러오기\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <PaletteContainer />\n        <CounterContainer /> {/* ****(2) 대체하기 */}\n        <WaitingList />\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n그럼, 카운터쪽 구현도 끝납니다! 버튼들을 눌러보세요.\n\n![](https://i.imgur.com/m55EbMQ.png)\n\n[![Edit colorful-counter [counter]](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/04rn6km9zn)\n\n## 3-4. 대기자 명단 만들기\n\n이제 카운터 아래쪽에 있는 대기자 명단 기능의 상태관리 작업을 해줄 차례입니다. 이번에는, redux-actions 라는 라이브러리를 활용하여 리덕스 모듈 작성을 더욱 손쉽게 하는 방법을 알아보겠습니다.\n\n### 액션 타입 정의하기\n\n우선, waiting.js 라는 리덕스 모듈을 만들고, 필요한 액션 타입들을 정의해주겠습니다.\n\n#### src/store/modules/waiting.js\n\n```javascript\nconst CHANGE_INPUT = 'waiting/CHANGE_INPUT'; // 인풋 값 변경\nconst CREATE = 'waiting/CREATE'; // 명단에 이름 추가\nconst ENTER = 'waiting/ENTER'; // 입장\nconst LEAVE = 'waiting/LEAVE'; // 나감\n```\n\n각 액션들마다, 필요로 하는 파라미터값들이 다릅니다. 예를들어서 CHANGE_INPUT 과 CREATE 는 문자열 상태의 값을 받아와야 할 것이고, ENTER 와 LEAVE 는 아이템의 id 값을 받아와야 하겠죠.\n\n### 액션 생성함수 만들기\n\n우리는 잠시 후에, 액션 생성 함수를 간편하게 만들 수 있게 해주는 redux-actions 의 `createAction` 이라는 함수를 사용하여 작성해볼건데요, 이는 [FSA](https://github.com/redux-utilities/flux-standard-action) 규칙을 따르는 액션 객체를 만들어주는데, 이 FSA 규칙은 읽기 쉽고, 유용하고, 간단한 액션 객체를 만들기 위해서 만들어졌습니다.\n\nFSA 에선 다음 조건들을 **필수적으로** 갖추고있어야 합니다.\n\n- 순수 자바스크립트 객체이며,\n- type 값이 있어야 합니다.\n\n그리고 다음 사항들은 선택적으로 필요합니다.\n\n- error 값이 있음\n- payload 값이 있음\n- meta 값이 있음\n\n여기서 payload 부분을 주시하셔야 되는데, FSA 규칙을 따르는 액션 객체는, 액션에서 사용 할 파라미터의 필드명을 payload 로 통일 시킵니다. 이를 통하여, 우리는 액션 생성 함수를 훨씬 더 쉽게 작성 할 수 있습니다.\n\nerror 는 에러가 발생 할 시 넣어 줄 수 있는 값이고, meta 는 상태 변화에 있어서 완전히 핵심적이지는 않지만 참조할만한 값을 넣어줍니다.\n\n그럼, 먼저 FSA 규칙을 준수하여 액션 생성 함수를 작성해볼까요?\n\n#### src/store/modules/waiting.js\n\n```javascript\nconst CHANGE_INPUT = 'waiting/CHANGE_INPUT'; // 인풋 값 변경\nconst CREATE = 'waiting/CREATE'; // 명단에 이름 추가\nconst ENTER = 'waiting/ENTER'; // 입장\nconst LEAVE = 'waiting/LEAVE'; // 나감\n\n// **** FSA 규칙을 따르는 액션 생성 함수 정의\nexport const changeInput = text => ({ type: CHANGE_INPUT, payload: text });\nexport const create = text => ({ type: CREATE, payload: text });\nexport const enter = id => ({ type: ENTER, payload: id });\nexport const leave = id => ({ type: LEAVE, payload: id });\n```\n\n### createAction 사용하기\n\n위 코드는, createAction 을 사용하게 된다면 다음과 같이 대체 할 수 있습니다.\n\n#### src/store/modules/waiting.js\n\n```javascript\nimport { createAction } from 'redux-actions';\n\nconst CHANGE_INPUT = 'waiting/CHANGE_INPUT'; // 인풋 값 변경\nconst CREATE = 'waiting/CREATE'; // 명단에 이름 추가\nconst ENTER = 'waiting/ENTER'; // 입장\nconst LEAVE = 'waiting/LEAVE'; // 나감\n\n// **** createAction 으로 액션 만들기\nexport const changeInput = createAction(CHANGE_INPUT, text => text);\nexport const create = createAction(CREATE, text => text);\nexport const enter = createAction(ENTER, id => id);\nexport const leave = createAction(LEAVE, id => id);\n```\n\n훨씬 가독성이 좋죠? createAction 함수에서 두번째 파라미터로 받는 부분은 payloadCreator 로서, payload 를 어떻게 정할 지 설정합니다. 만약에 생략하면 기본적으로 `payload => payload` 형태로 되기 때문에, 위 코드를 다음과 같이 작성해도 작동에 있어선 차이가 없습니다.\n\n```javascript\nexport const leave = createAction(LEAVE);\nleave(1); // { type: LEAVE, payload: 1 }\n```\n\n그 대신에 이렇게 두번째 파라미터를 생략한다면, 해당 액션에서 어떠한 값을 payload 로 설정하게 했더라? 하고 헷갈릴 가능성이 있습니다.\n\n현재 상황에서는, 데이터를 새로 생성 할 때마다 고유 id 값을 주어야 하는데요, 이전에 우리는 \"변화를 일으키는 함수, 리듀서는 순수한 함수여야 합니다.\" 라고 배웠습니다. 데이터에 고유 id 를 주는 작업은 리듀서에서 발생하면 안되고, 액션이 스토어에 디스패치 되기 전에 이뤄져야 합니다.\n\n그걸 하기 위해서, 액션 생성함수를 조금 수정해주는 방법도 있습니다. 다음과 같이 코드를 수정해주세요.\n\n```javascript\nimport { createAction, handleActions } from 'redux-actions';\n\nconst CHANGE_INPUT = 'waiting/CHANGE_INPUT'; // 인풋 값 변경\nconst CREATE = 'waiting/CREATE'; // 명단에 이름 추가\nconst ENTER = 'waiting/ENTER'; // 입장\nconst LEAVE = 'waiting/LEAVE'; // 나감\n\nlet id = 3;\n// createAction 으로 액션 생성함수 정의\nexport const changeInput = createAction(CHANGE_INPUT, text => text);\nexport const create = createAction(CREATE, text => ({ text, id: id++ }));\nexport const enter = createAction(ENTER, id => id);\nexport const leave = createAction(LEAVE, id => id);\n\nexport default handleActions({});\n```\n\n그러면, 이렇게 작동하게 됩니다.\n\n```javscript\ncreate('hello');\n{ type: CREATE,  payload: { id: 3, text: 'hello' } }\ncreate('bye');\n{ type: CREATE,  payload: { id: 4, text: 'bye' } }\n```\n\n### 초기 상태 및 리듀서 정의\n\n이제 이 모듈의 초기 상태와 리듀서를 정의해주겠습니다. 리듀서를 만들 땐, redux-actions 의 `handleActions` 를 사용하면 훨씬 편하게 작성 할 수 있습니다.\n\n```javascript\nimport { createAction, handleActions } from 'redux-actions';\n\nconst CHANGE_INPUT = 'waiting/CHANGE_INPUT'; // 인풋 값 변경\nconst CREATE = 'waiting/CREATE'; // 명단에 이름 추가\nconst ENTER = 'waiting/ENTER'; // 입장\nconst LEAVE = 'waiting/LEAVE'; // 나감\n\nlet id = 3;\n// createAction 으로 액션 생성함수 정의\nexport const changeInput = createAction(CHANGE_INPUT, text => text);\nexport const create = createAction(CREATE, text => ({ text, id: id++ }));\nexport const enter = createAction(ENTER, id => id);\nexport const leave = createAction(LEAVE, id => id);\n\n// **** 초기 상태 정의\nconst initialState = {\n  input: '',\n  list: [\n    {\n      id: 0,\n      name: '홍길동',\n      entered: true,\n    },\n    {\n      id: 1,\n      name: '콩쥐',\n      entered: false,\n    },\n    {\n      id: 2,\n      name: '팥쥐',\n      entered: false,\n    },\n  ],\n};\n\n// **** handleActions 로 리듀서 함수 작성\nexport default handleActions(\n  {\n    [CHANGE_INPUT]: (state, action) => ({\n      ...state,\n      input: action.payload,\n    }),\n    [CREATE]: (state, action) => ({\n      ...state,\n      list: state.list.concat({\n        id: action.payload.id,\n        name: action.payload.text,\n        entered: false,\n      }),\n    }),\n    [ENTER]: (state, action) => ({\n      ...state,\n      list: state.list.map(\n        item =>\n          item.id === action.payload\n            ? { ...item, entered: !item.entered }\n            : item\n      ),\n    }),\n    [LEAVE]: (state, action) => ({\n      ...state,\n      list: state.list.filter(item => item.id !== action.payload),\n    }),\n  },\n  initialState\n);\n```\n\nhandleActions 를 사용하면, 더이상 switch / case 문을 사용 할 필요가 없이 각 액션 타입마다 업데이터 함수를 구현하는 방식으로 할 수 있어서 가독성이 더 좋아집니다.\n\n여기서, CREATE, ENTER, LEAVE 의 액션의 경우엔 배열을 다뤄야 하는 것들이라, concat, map, filter 를 사용하여 불변성을 유지하면서 배열에 새로운 값을 지정해주었습니다.\n\n### 루트 리듀서에 포함 시키기\n\n새 리듀서를 만들었으니, 루트 리듀서쪽에도 포함시켜줘야겠죠?\n\n#### src/store/modules/index.js\n\n```javascript\nimport { combineReducers } from 'redux';\nimport counter from './counter';\nimport waiting from './waiting'; // **** 불러오기\n\nexport default combineReducers({\n  counter,\n  waiting, // **** 추가\n});\n```\n\n### WaitingListContainer 만들기\n\n이제 컨테이너 컴포넌트를 만들어주겠습니다!\n\n#### src/containers/WaitingListContainer.js\n\n```javascript\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport { bindActionCreators } from 'redux';\nimport * as waitingActions from '../store/modules/waiting';\nimport WaitingList from '../components/WaitingList';\n\nclass WaitingListContainer extends Component {\n  // 인풋 변경 이벤트\n  handleChange = e => {\n    const { WaitingActions } = this.props;\n    WaitingActions.changeInput(e.target.value);\n  };\n  // 등록 이벤트\n  handleSubmit = e => {\n    e.preventDefault();\n    const { WaitingActions, input } = this.props;\n    WaitingActions.create(input); // 등록\n    WaitingActions.changeInput(''); // 인풋 값 초기화\n  };\n  // 입장\n  handleEnter = id => {\n    const { WaitingActions } = this.props;\n    WaitingActions.enter(id);\n  };\n  // 나가기\n  handleLeave = id => {\n    const { WaitingActions } = this.props;\n    WaitingActions.leave(id);\n  };\n  render() {\n    const { input, list } = this.props;\n    return (\n      <WaitingList\n        input={input}\n        waitingList={list}\n        onChange={this.handleChange}\n        onSubmit={this.handleSubmit}\n        onEnter={this.handleEnter}\n        onLeave={this.handleLeave}\n      />\n    );\n  }\n}\n\nconst mapStateToProps = ({ waiting }) => ({\n  input: waiting.input,\n  list: waiting.list,\n});\n\n// 이런 구조로 하면 나중에 다양한 리덕스 모듈을 적용해야 하는 상황에서 유용합니다.\nconst mapDispatchToProps = dispatch => ({\n  WaitingActions: bindActionCreators(waitingActions, dispatch),\n  // AnotherActions: bindActionCreators(anotherActions, dispatch)\n});\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(WaitingListContainer);\n```\n\n그리고, App.js 에서 WaitingList 를 WaitingListContainer 로 교체하세요.\n\n#### src/App.js\n\n```javascript\nimport React, { Component } from 'react';\n\nimport './App.css';\nimport PaletteContainer from './containers/PaletteContainer';\nimport CounterContainer from './containers/CounterContainer';\nimport WaitingListContainer from './containers/WaitingListContainer'; // **** 불러오기\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <PaletteContainer />\n        <CounterContainer />\n        <WaitingListContainer /> {/* **** 교체하기 */}\n      </div>\n    );\n  }\n}\n\nexport default App;\n```\n\n### WaitingList 내부 구현\n\n껍데기만 구현되어있었던 WaitingList 컴포넌트에 전달한 props 들을 유의미하게 사용하도록 기능들을 구현해주겠습니다.\n\n#### src/components/WaitingList.js\n\n```javascript\nimport React from 'react';\nimport './WaitingList.css';\n\nconst WaitingItem = ({ text, entered, onEnter, onLeave }) => {\n  return (\n    <li>\n      <div className={`text ${entered ? 'entered' : ''}`}>{text}</div>\n      <div className=\"buttons\">\n        <button onClick={onEnter}>입장</button>\n        <button onClick={onLeave}>나감</button>\n      </div>\n    </li>\n  );\n};\n\nconst WaitingList = ({\n  input, // **** 추가됨\n  waitingList,\n  onChange, // **** 추가됨\n  onSubmit, // **** 추가됨\n  onEnter,\n  onLeave,\n}) => {\n  // **** 데이터를 컴포넌트 리스트로 변환\n  const waitingItems = waitingList.map(w => (\n    <WaitingItem\n      key={w.id}\n      text={w.name}\n      entered={w.entered}\n      id={w.id}\n      onEnter={() => onEnter(w.id)}\n      onLeave={() => onLeave(w.id)}\n    />\n  ));\n  return (\n    <div className=\"WaitingList\">\n      <h2>대기자 명단</h2>\n      {/* form 과 input 에 이벤트 및 값 설정 */}\n      <form onSubmit={onSubmit}>\n        <input value={input} onChange={onChange} />\n        <button>등록</button>\n      </form>\n      <ul>{waitingItems}</ul> {/* 하드코딩된것을 컴포넌트 배열로 교체 */}\n    </div>\n  );\n};\n\nexport default WaitingList;\n```\n\n이제 대기자 명단 구현도 끝났습니다!\n\n![](https://i.imgur.com/HMCaxWQ.png)\n\n[![Edit colorful-counter [waiting-list]](https://codesandbox.io/static/img/play-codesandbox.svg)](https://codesandbox.io/s/o9q7mj6o9y)\n",
    short_description: null,
    thumbnail:
      'https://images.velog.io/post-images/velopert/5058d7d0-b352-11e8-9696-f1fffe8a36f1/redux.png',
    is_markdown: true,
    is_temp: false,
    original_post_id: null,
    url_slug: 'Redux-3-리덕스를-리액트와-함께-사용하기-nvjltahf5e',
    likes: 57,
    meta: {
      code_theme: '',
      short_description: null,
    },
    views: 19640,
    is_private: false,
    released_at: '2018-09-08T10:31:14.962Z',
  },
  {
    title: 'Redux (1) 소개 및 개념정리',
    body: '## 1-1. 리덕스 소개\n\n리덕스는, 가장 사용률이 높은 상태관리 라이브러리입니다. 리덕스를 사용하면, 여러분이 만들게 될 컴포넌트들의 상태 관련 로직들을 다른 파일들로 분리시켜서 더욱 효율적으로 관리 할 수 있습니다. 또한, 컴포넌트끼리 상태를 공유하게 될 때 여러 컴포넌트를 거치지 않고도 손쉽게 상태 값을 전달 할 수 있습니다.\n\n추가적으로, 리덕스의 미들웨어라는 기능을 통하여 비동기 작업, 로깅 등의 확장적인 작업들을 더욱 쉽게 할 수도 있게 해줍니다. 이 미들웨어에 대해서는 나중에 다뤄보게 됩니다!\n\n### 필요성 파악하기\n\n리덕스는 글로벌 상태 관리를 하게 될 때 굉장히 효과적입니다. 물론, 리덕스를 사용하는것이 유일한 솔루션은 아닙니다. Context API 를 통해서도 동일한 작업을 할 수 있다는것을 미리 알려드립니다.\n\n먼저, 투두 리스트 앱의 컴포넌트 구조를 살펴보겠습니다.\n\n![](https://i.imgur.com/mY3eftZ.png)\n\n투두리스트에서는, CreateForm 에서 우리가 값을 투두 아이템을 추가하면, App 에서 CreateForm 에게 전달해준 handleCreate 함수가 호출되고, 이 함수가 호출 되면 App 의 state 안에 들어있는 todos 값이 업데이트 됩니다.\n\ntodos 값이 업데이트 되면, 해당 값이 TodoList 한테 전달되어서 우리가 만든 투두아이템들이 모두 잘 나타나게 되겠죠.\n\n위 구조를 보시면, CreateForm 와, TodoList 간의 데이터 교류를 하기 위해서 App 이라는 부모 컴포넌트가 중간자 역할을 해주었습니다.\n\n위와 같이, 간단한 구조를 갖추고 있는 프로젝트는 글로벌 상태 관리를 위하여 따로 상태 관리 라이브러리를 사용하실 필요가 없습니다.\n\n하지만, 컴포넌트 구조가 조금만 더 복잡해지면 어떨까요?\n\n![](https://i.imgur.com/RFjWPuh.png)\n\nRoot 컴포넌트에는 something 이라는 상태 값이 있고, onDoSomething 이라는 함수가 something 값에 변화를 줍니다.\n\nonDoSomething 은 Root -> B -> H 로 전달되고, H 에서 이벤트가 발생하여 이 함수가 호출되면 something 이 Root -> A -> E -> F 로 전달됩니다.\n\nprops 가 필요한 곳으로 제대로 전달되게 하기 위하여, 실제로는 해당 props 를 사용하지 않는 컴포넌트를 거쳐가야 한다는 것은 리렌더링 하게 될 때 비효율적이기도하고, 굉장히 귀찮은 작업이기도 합니다. 상위 컴포넌트에서 props 이름을 바꿔준다면 그 아래에도 쭉 바꿔줘야 하니까요.\n\n리덕스가 있다면, 다음과 같은 구조로 작업을 진행 할 수 있게 됩니다.\n\n![](https://i.imgur.com/U3S2iJ8.png)\n\n앱이 지니고 있는 상태와, 상태 변화 로직이 들어있는 **스토어**를 통하여, 우리가 원하는 컴포넌트에 원하는 상태값과 함수를 직접 주입해줄 수 있게 됩니다.\n\n이런 식으로, 더 쉬운 글로벌 상태 관리를 위하여 리덕스를 사용하기도 하고, 조금 더 체계적이고 편리한 상태 관리를 하기 위하여 사용을 하는데, 후자의 경우엔 실제로 사용을 해봐야 경험을 해볼 수 있을 것입니다. 그럼, 계속해서 진행해볼까요?\n\n## 1-2. 개념 미리 정리하기\n\n앞으로 접하게 될 키워드들에 대해서 미리 알아보는 시간을 가져보겠습니다. 대략적인 개념만 간략히 알아보는 것 이므로, 도중에 잘 이해가 안가는게 있더라도, 나중에 직접 사용해본 다음에 이 섹션으로 다시 돌아와서 다시 읽으시면 이해가 더욱 잘 될 것입니다.\n\n### 액션 (Action)\n\n상태에 어떠한 변화가 필요하게 될 땐, 우리는 액션이란 것을 발생시킵니다. 이는, 하나의 객체로 표현되는데요, 액션 객체는 다음과 같은 형식으로 이뤄져있습니다.\n\n```javascript\n{\n  type: "TOGGLE_VALUE"\n}\n```\n\n액션 객체는 `type` 필드를 필수적으로 가지고 있어야하고 그 외의 값들은 개발자 마음대로 넣어줄 수 있습니다.\n\n예시: \n\n```javascript\n{\n  type: "ADD_TODO",\n  data: {\n    id: 0,\n    text: "리덕스 배우기"\n  }\n}\n```\n```javascript\n{\n  type: "CHANGE_INPUT",\n  text: "안ㄴ"\n}\n```\n\n### 액션 생성함수 (Action Creator)\n\n액션 생성함수는, 액션을 만드는 함수입니다. 단순히 파라미터를 받아와서 액션 객체 형태로 만들어주죠.\n\n```javascript\nfunction addTodo(data) {\n  return {\n    type: "ADD_TODO",\n    data\n  };\n}\n\n// 화살표 함수로도 만들 수 있습니다.\nconst changeInput = text => ({ \n  type: "CHANGE_INPUT",\n  text\n});\n```\n\n### 리듀서 (Reducer)\n\n리듀서는 변화를 일으키는 함수입니다. 리듀서는 두가지의 파라미터를 받아옵니다.\n\n```javascript\nfunction reducer(state, action) {\n  // 상태 업데이트 로직\n  return alteredState;\n}\n```\n\n리듀서는, 현재의 상태와, 전달 받은 액션을 참고하여 새로운 상태를 만들어서 반환합니다. 자세한건, 추후 직접 구현하면서 알아보겠습니다.\n\n### 스토어 (Store)\n\n리덕스에서는 한 애플리케이션 당 하나의 스토어를 만들게 됩니다. 스토어 안에는, 현재의 앱 상태와, 리듀서가 들어가있고, 추가적으로 몇가지 내장 함수들이 있습니다.\n\n### 디스패치 (dispatch)\n\n디스패치는 스토어의 내장함수 중 하나입니다. 디스패치는, 액션을 발생 시키는 것 이라고 이해하시면 됩니다. dispatch 라는 함수에는 액션을 파라미터로 전달합니다.. dispatch(action) 이런식으로 말이죠.\n\n그렇게 호출을 하면, 스토어는 리듀서 함수를 실행시켜서 해당 액션을 처리하는 로직이 있다면 액션을 참고하여 새로운 상태를 만들어줍니다.\n\n### 구독 (subscribe)\n\n구독 또한 스토어의 내장함수 중 하나입니다. subscribe 함수는, 함수 형태의 값을 파라미터로 받아옵니다. subscribe 함수에 특정 함수를 전달해주면, 액션이 디스패치 되었을 때 마다 전달해준 함수가 호출됩니다.\n\n',
    short_description: null,
    thumbnail:
      'https://images.velog.io/post-images/velopert/654650b0-b351-11e8-9696-f1fffe8a36f1/redux.png',
    is_markdown: true,
    is_temp: false,
    fk_user_id: 'c76ccc50-b34d-11e8-b01f-598f1220d1c8',
    original_post_id: null,
    url_slug: 'Redux-1-소개-및-개념정리-zxjlta8ywt',
    likes: 78,
    meta: {
      code_theme: '',
      short_description:
        '리덕스 소개  리덕스는, 가장 사용률이 높은 상태관리 라이브러리입니다. 리덕스를 사용하면, 여러분이 만들게 될 컴포넌트들의 상태 관련 로직들을 다른 파일들로 분리시켜서 더',
    },
    views: 25851,
    is_private: false,
    released_at: '2018-09-08T10:24:40.642Z',
  },
]
